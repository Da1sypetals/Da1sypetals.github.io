#import "/book.typ": book-page
#show: book-page.with(title: "Network Basics")
 

// ################### Content ###################

= Rust网络小知识
#text(size: 12pt, style: "italic")[Disclaimer: I know nothing about computer networking.]
+ 调用一次`read_to_end`等方法就会阻塞（阻塞当前线程，或者称为异步）等待一个发向自己的消息。调用一次`write_all`等方法就会发送一次到目标的消息。
+ 协议封包导致 *发送端* 发送的 和 *接收端* 收到的东西一定是一样的
  - 如果在发送的一半就read了，那么就会 *阻塞或者读取失败直接返回*，具体看使用的接口。
+ `write` & `write_all`
  - *不要使用`write`。*他只是用来实现下面的方法的。
    - #text(size: 11pt)[`write`会尝试发送数据，但是可能不会发送所有数据；返回“发送的数据字节数”。]
  - `write_all`会持续尝试，直到所有数据都发送。
  - `flush` 会保证所有数据都送到。在`write_all`之后配合使用。
+ `read` & `read_to_end` 
  - *不要使用`read`*。他只是用来实现下面的其他方法的。
  - `read_to_end` 从开头读到EOF。如果对方还没发送完，那你就会阻塞。
  - 其他一般使用的方法包括`read_exact`, `read_to_string`


#v(1%)
#line(length: 100%)
#v(1%)
Deepseek解答：
```md
`s.send()` 和 `s.sendall()` 是 Python 中用于发送 TCP 数据的两个方法，它们的行为在特定情况下可能会有所不同，主要取决于网络条件和缓冲区状态。

### 1. **网络拥塞或缓冲区满**
   - **`s.send()`**: 这个方法会尝试发送数据，但可能不会一次性发送所有数据。如果网络拥塞或接收方的缓冲区已满，`s.send()` 可能会只发送部分数据，并返回实际发送的字节数。这意味着你需要检查返回值，并在必要时多次调用 `s.send()` 来发送剩余的数据。
   - **`s.sendall()`**: 这个方法会持续尝试发送所有数据，直到所有数据都被成功发送或发生错误。它会处理网络拥塞或缓冲区满的情况，自动重试发送剩余的数据，直到所有数据都被发送完毕或抛出异常。

### 2. **非阻塞套接字**
   - **`s.send()`**: 如果套接字设置为非阻塞模式（`s.setblocking(False)`），`s.send()` 可能会立即返回，即使没有发送任何数据。在这种情况下，返回值可能是 0，表示没有数据被发送。
   - **`s.sendall()`**: 即使在非阻塞模式下，`s.sendall()` 也会尝试发送所有数据，但它可能会抛出 `BlockingIOError` 异常，表示无法立即发送数据。你需要处理这个异常，并在稍后重试。

### 3. **错误处理**
   - **`s.send()`**: 如果发送过程中发生错误（如连接中断），`s.send()` 会抛出异常，并且你可能需要手动处理未发送的数据。
   - **`s.sendall()`**: 如果发送过程中发生错误，`s.sendall()` 也会抛出异常，但它会确保在抛出异常之前尽可能多地发送数据。

### 总结
- **使用 `s.send()`** 时，你需要手动处理部分发送的情况，并可能需要多次调用它来发送所有数据。
- **使用 `s.sendall()`** 时，它会自动处理部分发送的情况，确保所有数据都被发送，除非发生错误。

因此，如果你希望简化代码并确保所有数据都被发送，通常推荐使用 `s.sendall()`。如果你需要更细粒度的控制（例如在非阻塞模式下），则可以使用 `s.send()`。
```